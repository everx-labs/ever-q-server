"""
Due to GraphQL limitations big numbers are returned as a string.
You can specify format used to string representation for big integers.
"""
enum BigIntFormat {
    " Hexadecimal representation started with 0x (default) "
    HEX
    " Decimal representation "
    DEC
}
input StringFilter {
	eq: String
	ne: String
	gt: String
	lt: String
	ge: String
	le: String
	in: [String]
	notIn: [String]
}

input BooleanFilter {
	eq: Boolean
	ne: Boolean
	gt: Boolean
	lt: Boolean
	ge: Boolean
	le: Boolean
	in: [Boolean]
	notIn: [Boolean]
}

input IntFilter {
	eq: Int
	ne: Int
	gt: Int
	lt: Int
	ge: Int
	le: Int
	in: [Int]
	notIn: [Int]
}

input FloatFilter {
	eq: Float
	ne: Float
	gt: Float
	lt: Float
	ge: Float
	le: Float
	in: [Float]
	notIn: [Float]
}

enum InMsgTypeEnum {
    External
    Ihr
    Immediately
    Final
    Transit
    DiscardedFinal
    DiscardedTransit
}

enum OutMsgTypeEnum {
    External
    Immediately
    OutMsgNew
    Transit
    DequeueImmediately
    Dequeue
    TransitRequired
    DequeueShort
    None
}

enum MessageTypeEnum {
    Internal
    ExtIn
    ExtOut
}

enum MessageProcessingStatusEnum {
    Unknown
    Queued
    Processing
    Preliminary
    Proposed
    Finalized
    Refused
    Transiting
}

enum BlockProcessingStatusEnum {
    Unknown
    Proposed
    Finalized
    Refused
}

enum SplitTypeEnum {
    None
    Split
    Merge
}

enum AccountTypeEnum {
    Uninit
    Active
    Frozen
}

enum TransactionTypeEnum {
    Ordinary
    Storage
    Tick
    Tock
    SplitPrepare
    SplitInstall
    MergePrepare
    MergeInstall
}

enum TransactionProcessingStatusEnum {
    Unknown
    Preliminary
    Proposed
    Finalized
    Refused
}

enum AccountStatusEnum {
    Uninit
    Active
    Frozen
    NonExist
}

enum AccountStatusChangeEnum {
    Unchanged
    Frozen
    Deleted
}

enum ComputeTypeEnum {
    Skipped
    Vm
}

enum SkipReasonEnum {
    NoState
    BadState
    NoGas
}

enum BounceTypeEnum {
    NegFunds
    NoFunds
    Ok
}

type OtherCurrency {
	currency: Float
	value(format: BigIntFormat): String
}

type ExtBlkRef {
	end_lt(format: BigIntFormat): String
	seq_no: Float
	root_hash: String
	file_hash: String
}

type MsgEnvelope {
	msg_id: String
	next_addr: String
	cur_addr: String
	fwd_fee_remaining(format: BigIntFormat): String
}

type InMsg {
	"""
	- 0 – external
	- 1 – ihr
	- 2 – immediately
	- 3 – final
	- 4 – transit
	- 5 – discardedFinal
	- 6 – discardedTransit
	"""
	msg_type: Int
	msg_type_name: InMsgTypeEnum
	msg_id: String
	ihr_fee(format: BigIntFormat): String
	proof_created: String
	in_msg: MsgEnvelope
	fwd_fee(format: BigIntFormat): String
	out_msg: MsgEnvelope
	transit_fee(format: BigIntFormat): String
	transaction_id: String
	proof_delivered: String
}

type OutMsg {
	"""
	- 0 – external
	- 1 – immediately
	- 2 – outMsgNew
	- 3 – transit
	- 4 – dequeueImmediately
	- 5 – dequeue
	- 6 – transitRequired
	- 7 – dequeueShort
	- -1 – none
	"""
	msg_type: Int
	msg_type_name: OutMsgTypeEnum
	msg_id: String
	transaction_id: String
	out_msg: MsgEnvelope
	reimport: InMsg
	imported: InMsg
	import_block_lt(format: BigIntFormat): String
	msg_env_hash: String
	next_workchain: Int
	next_addr_pfx(format: BigIntFormat): String
}

type BlockValueFlow {
	"Amount of grams amount to the next block."
	to_next_blk(format: BigIntFormat): String
	"Amount of non gram cryptocurrencies to the next block."
	to_next_blk_other: [OtherCurrency]
	"Amount of grams exported."
	exported(format: BigIntFormat): String
	"Amount of non gram cryptocurrencies exported."
	exported_other: [OtherCurrency]
	fees_collected(format: BigIntFormat): String
	fees_collected_other: [OtherCurrency]
	created(format: BigIntFormat): String
	created_other: [OtherCurrency]
	"Amount of grams imported."
	imported(format: BigIntFormat): String
	"Amount of non gram cryptocurrencies imported."
	imported_other: [OtherCurrency]
	"Amount of grams transferred from previous block."
	from_prev_blk(format: BigIntFormat): String
	"Amount of non gram cryptocurrencies transferred from previous block."
	from_prev_blk_other: [OtherCurrency]
	"Amount of grams minted in this block."
	minted(format: BigIntFormat): String
	minted_other: [OtherCurrency]
	"Amount of import fees in grams"
	fees_imported(format: BigIntFormat): String
	"Amount of import fees in non gram currencies."
	fees_imported_other: [OtherCurrency]
}

type BlockAccountBlocksTransactions {
	lt(format: BigIntFormat): String
	transaction_id: String
	total_fees(format: BigIntFormat): String
	total_fees_other: [OtherCurrency]
}

type BlockAccountBlocks {
	account_addr: String
	transactions: [BlockAccountBlocksTransactions]
	"old version of block hashes"
	old_hash: String
	"new version of block hashes"
	new_hash: String
	tr_count: Int
}

type BlockStateUpdate {
	new: String
	new_hash: String
	new_depth: Int
	old: String
	old_hash: String
	old_depth: Int
}

"Shard description"
type BlockMasterShardHashesDescr {
	"uint32 sequence number"
	seq_no: Float
	"Returns last known master block at the time of shard generation."
	reg_mc_seqno: Float
	"Logical time of the shardchain start"
	start_lt(format: BigIntFormat): String
	"Logical time of the shardchain end"
	end_lt(format: BigIntFormat): String
	"Returns last known master block at the time of shard generation. The shard block configuration is derived from that block."
	root_hash: String
	"Shard block file hash."
	file_hash: String
	"""
	TON Blockchain supports dynamic sharding, so the shard configuration may change from block to block because of shard merge and split events. Therefore, we cannot simply say that each shardchain corresponds to a fixed set of account chains.
	A shardchain block and its state may each be classified into two distinct parts. The parts with the ISP-dictated form of will be called the split parts of the block and its state, while the remainder will be called the non-split parts.
	The masterchain cannot be split or merged.
	"""
	before_split: Boolean
	before_merge: Boolean
	want_split: Boolean
	want_merge: Boolean
	nx_cc_updated: Boolean
	flags: Int
	next_catchain_seqno: Float
	next_validator_shard: String
	min_ref_mc_seqno: Float
	"Generation time in uint32"
	gen_utime: Float
	gen_utime_string: String
	"""
	- 0 – none
	- 2 – split
	- 3 – merge
	"""
	split_type: Int
	split_type_name: SplitTypeEnum
	split: Float
	"Amount of fees collected int his shard in grams."
	fees_collected(format: BigIntFormat): String
	"Amount of fees collected int his shard in non gram currencies."
	fees_collected_other: [OtherCurrency]
	"Amount of funds created in this shard in grams."
	funds_created(format: BigIntFormat): String
	"Amount of funds created in this shard in non gram currencies."
	funds_created_other: [OtherCurrency]
}

type BlockMasterShardHashes {
	"Uint32 workchain ID"
	workchain_id: Int
	"Shard ID"
	shard: String
	"Shard description"
	descr: BlockMasterShardHashesDescr
}

type BlockMasterShardFees {
	workchain_id: Int
	shard: String
	"Amount of fees in grams"
	fees(format: BigIntFormat): String
	"Array of fees in non gram crypto currencies"
	fees_other: [OtherCurrency]
	"Amount of fees created during shard"
	create(format: BigIntFormat): String
	"Amount of non gram fees created in non gram crypto currencies during the block."
	create_other: [OtherCurrency]
}

type BlockMasterPrevBlkSignatures {
	node_id: String
	r: String
	s: String
}

"Configuration parameter 6"
type BlockMasterConfigP6 {
	mint_new_price: String
	mint_add_price: String
}

type BlockMasterConfigP7 {
	currency: Float
	value: String
}

"Global version"
type BlockMasterConfigP8 {
	version: Float
	capabilities: String
}

type ConfigProposalSetup {
	min_tot_rounds: Int
	max_tot_rounds: Int
	min_wins: Int
	max_losses: Int
	min_store_sec: Float
	max_store_sec: Float
	bit_price: Float
	cell_price: Float
}

"Config voting setup"
type BlockMasterConfigP11 {
	normal_params: ConfigProposalSetup
	critical_params: ConfigProposalSetup
}

type BlockMasterConfigP12 {
	workchain_id: Int
	enabled_since: Float
	actual_min_split: Int
	min_split: Int
	max_split: Int
	active: Boolean
	accept_msgs: Boolean
	flags: Int
	zerostate_root_hash: String
	zerostate_file_hash: String
	version: Float
	basic: Boolean
	vm_version: Int
	vm_mode: String
	min_addr_len: Int
	max_addr_len: Int
	addr_len_step: Int
	workchain_type_id: Float
}

"Block create fees"
type BlockMasterConfigP14 {
	masterchain_block_fee(format: BigIntFormat): String
	basechain_block_fee(format: BigIntFormat): String
}

"Election parameters"
type BlockMasterConfigP15 {
	validators_elected_for: Float
	elections_start_before: Float
	elections_end_before: Float
	stake_held_for: Float
}

"Validators count"
type BlockMasterConfigP16 {
	max_validators: Int
	max_main_validators: Int
	min_validators: Int
}

"Validator stake parameters"
type BlockMasterConfigP17 {
	min_stake(format: BigIntFormat): String
	max_stake(format: BigIntFormat): String
	min_total_stake(format: BigIntFormat): String
	max_stake_factor: Float
}

type BlockMasterConfigP18 {
	utime_since: Float
	utime_since_string: String
	bit_price_ps(format: BigIntFormat): String
	cell_price_ps(format: BigIntFormat): String
	mc_bit_price_ps(format: BigIntFormat): String
	mc_cell_price_ps(format: BigIntFormat): String
}

type GasLimitsPrices {
	gas_price(format: BigIntFormat): String
	gas_limit(format: BigIntFormat): String
	special_gas_limit(format: BigIntFormat): String
	gas_credit(format: BigIntFormat): String
	block_gas_limit(format: BigIntFormat): String
	freeze_due_limit(format: BigIntFormat): String
	delete_due_limit(format: BigIntFormat): String
	flat_gas_limit(format: BigIntFormat): String
	flat_gas_price(format: BigIntFormat): String
}

type BlockLimitsBytes {
	underload: Float
	soft_limit: Float
	hard_limit: Float
}

type BlockLimitsGas {
	underload: Float
	soft_limit: Float
	hard_limit: Float
}

type BlockLimitsLtDelta {
	underload: Float
	soft_limit: Float
	hard_limit: Float
}

type BlockLimits {
	bytes: BlockLimitsBytes
	gas: BlockLimitsGas
	lt_delta: BlockLimitsLtDelta
}

type MsgForwardPrices {
	lump_price(format: BigIntFormat): String
	bit_price(format: BigIntFormat): String
	cell_price(format: BigIntFormat): String
	ihr_price_factor: Float
	first_frac: Int
	next_frac: Int
}

"Catchain config"
type BlockMasterConfigP28 {
	shuffle_mc_validators: Boolean
	mc_catchain_lifetime: Float
	shard_catchain_lifetime: Float
	shard_validators_lifetime: Float
	shard_validators_num: Float
}

"Consensus config"
type BlockMasterConfigP29 {
	new_catchain_ids: Boolean
	round_candidates: Float
	next_candidate_delay_ms: Float
	consensus_timeout_ms: Float
	fast_attempts: Float
	attempt_duration: Float
	catchain_max_deps: Float
	max_block_bytes: Float
	max_collated_bytes: Float
}

type ValidatorSetList {
	public_key: String
	weight(format: BigIntFormat): String
	adnl_addr: String
}

type ValidatorSet {
	utime_since: Float
	utime_since_string: String
	utime_until: Float
	utime_until_string: String
	total: Int
	total_weight(format: BigIntFormat): String
	list: [ValidatorSetList]
}

type BlockMasterConfigP39 {
	adnl_addr: String
	temp_public_key: String
	seqno: Float
	valid_until: Float
	signature_r: String
	signature_s: String
}

type BlockMasterConfig {
	"Address of config smart contract in the masterchain"
	p0: String
	"Address of elector smart contract in the masterchain"
	p1: String
	"Address of minter smart contract in the masterchain"
	p2: String
	"Address of fee collector smart contract in the masterchain"
	p3: String
	"Address of TON DNS root smart contract in the masterchain"
	p4: String
	"Configuration parameter 6"
	p6: BlockMasterConfigP6
	"Configuration parameter 7"
	p7: [BlockMasterConfigP7]
	"Global version"
	p8: BlockMasterConfigP8
	p9: [Float]
	p10: [Float]
	"Config voting setup"
	p11: BlockMasterConfigP11
	"Array of all workchains descriptions"
	p12: [BlockMasterConfigP12]
	"Block create fees"
	p14: BlockMasterConfigP14
	"Election parameters"
	p15: BlockMasterConfigP15
	"Validators count"
	p16: BlockMasterConfigP16
	"Validator stake parameters"
	p17: BlockMasterConfigP17
	"Storage prices"
	p18: [BlockMasterConfigP18]
	"Gas limits and prices in the masterchain"
	p20: GasLimitsPrices
	"Gas limits and prices in workchains"
	p21: GasLimitsPrices
	"Block limits in the masterchain"
	p22: BlockLimits
	"Block limits in workchains"
	p23: BlockLimits
	"Message forward prices in the masterchain"
	p24: MsgForwardPrices
	"Message forward prices in workchains"
	p25: MsgForwardPrices
	"Catchain config"
	p28: BlockMasterConfigP28
	"Consensus config"
	p29: BlockMasterConfigP29
	p31: [String]
	"Previous validators set"
	p32: ValidatorSet
	"Previous temprorary validators set"
	p33: ValidatorSet
	"Current validators set"
	p34: ValidatorSet
	"Current temprorary validators set"
	p35: ValidatorSet
	"Next validators set"
	p36: ValidatorSet
	"Next temprorary validators set"
	p37: ValidatorSet
	"Array of validator signed temprorary keys"
	p39: [BlockMasterConfigP39]
}

type BlockMaster {
	"Min block generation time of shards"
	min_shard_gen_utime: Float
	min_shard_gen_utime_string: String
	"Max block generation time of shards"
	max_shard_gen_utime: Float
	max_shard_gen_utime_string: String
	shard_hashes: [BlockMasterShardHashes]
	shard_fees: [BlockMasterShardFees]
	recover_create_msg: InMsg
	prev_blk_signatures: [BlockMasterPrevBlkSignatures]
	config_addr: String
	config: BlockMasterConfig
}

type BlockSignaturesSignatures {
	node_id: String
	"'R' part of signature"
	r: String
	"'s' part of signature"
	s: String
}

"Set of validator's signatures for the Block with correspond id"
type BlockSignatures {
	id: String
	"Signed block's gen_utime"
	gen_utime: Float
	gen_utime_string: String
	"Signed block's seq_no"
	seq_no: Float
	"Signed block's shard"
	shard: String
	"Signed block's workchain_id"
	workchain_id: Int
	"Signed block's merkle proof"
	proof: String
	validator_list_hash_short: Float
	catchain_seqno: Float
	sig_weight(format: BigIntFormat): String
	"Array of signatures from block's validators"
	signatures: [BlockSignaturesSignatures]
	block(timeout: Int, when: BlockSignaturesFilter): Block
}

"This is Block"
type Block {
	id: String
	"""
	Returns block processing status
	- 0 – unknown
	- 1 – proposed
	- 2 – finalized
	- 3 – refused
	"""
	status: Int
	status_name: BlockProcessingStatusEnum
	"uint32 global block ID"
	global_id: Float
	want_split: Boolean
	seq_no: Float
	after_merge: Boolean
	"uint 32 generation time stamp"
	gen_utime: Float
	gen_utime_string: String
	gen_catchain_seqno: Float
	flags: Int
	master_ref: ExtBlkRef
	"External block reference for previous block."
	prev_ref: ExtBlkRef
	"External block reference for previous block in case of shard merge."
	prev_alt_ref: ExtBlkRef
	"External block reference for previous block in case of vertical blocks."
	prev_vert_ref: ExtBlkRef
	prev_vert_alt_ref: ExtBlkRef
	"uin32 block version identifier"
	version: Float
	gen_validator_list_hash_short: Float
	before_split: Boolean
	after_split: Boolean
	want_merge: Boolean
	vert_seq_no: Float
	"""
	Logical creation time automatically set by the block formation start.
	Logical time is a component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see the TON blockchain specification
	"""
	start_lt(format: BigIntFormat): String
	"Logical creation time automatically set by the block formation end."
	end_lt(format: BigIntFormat): String
	"uint32 workchain identifier"
	workchain_id: Int
	shard: String
	"Returns last known master block at the time of shard generation."
	min_ref_mc_seqno: Float
	"Returns a number of a previous key block."
	prev_key_block_seqno: Float
	gen_software_version: Float
	gen_software_capabilities: String
	value_flow: BlockValueFlow
	in_msg_descr: [InMsg]
	rand_seed: String
	create_by: String
	out_msg_descr: [OutMsg]
	account_blocks: [BlockAccountBlocks]
	tr_count: Int
	state_update: BlockStateUpdate
	master: BlockMaster
	"true if this block is a key block"
	key_block: Boolean
	"Serialized bag of cell of this block encoded with base64"
	boc: String
	signatures(timeout: Int, when: BlockFilter): BlockSignatures
}

type TransactionStorage {
	"This field defines the amount of storage fees collected in grams."
	storage_fees_collected(format: BigIntFormat): String
	"This field represents the amount of due fees in grams, it might be empty."
	storage_fees_due(format: BigIntFormat): String
	"""
	This field represents account status change after the transaction is completed.
	- 0 – unchanged
	- 1 – frozen
	- 2 – deleted
	"""
	status_change: Int
	status_change_name: AccountStatusChangeEnum
}

type TransactionCredit {
	"The sum of due_fees_collected and credit must equal the value of the message received, plus its ihr_fee if the message has not been received via Instant Hypercube Routing, IHR (otherwise the ihr_fee is awarded to the validators)."
	due_fees_collected(format: BigIntFormat): String
	credit(format: BigIntFormat): String
	credit_other: [OtherCurrency]
}

type TransactionCompute {
	"""
	- 0 – skipped
	- 1 – vm
	"""
	compute_type: Int
	compute_type_name: ComputeTypeEnum
	"""
	Reason for skipping the compute phase. According to the specification, the phase can be skipped due to the absence of funds to buy gas, absence of state of an account or a message, failure to provide a valid state in the message
	- 0 – noState
	- 1 – badState
	- 2 – noGas
	"""
	skipped_reason: Int
	skipped_reason_name: SkipReasonEnum
	"This flag is set if and only if exit_code is either 0 or 1."
	success: Boolean
	"This parameter reflects whether the state passed in the message has been used. If it is set, the account_activated flag is used (see below)This parameter reflects whether the state passed in the message has been used. If it is set, the account_activated flag is used (see below)"
	msg_state_used: Boolean
	"The flag reflects whether this has resulted in the activation of a previously frozen, uninitialized or non-existent account."
	account_activated: Boolean
	"This parameter reflects the total gas fees collected by the validators for executing this transaction. It must be equal to the product of gas_used and gas_price from the current block header."
	gas_fees(format: BigIntFormat): String
	gas_used(format: BigIntFormat): String
	"This parameter reflects the gas limit for this instance of TVM. It equals the lesser of either the Grams credited in the credit phase from the value of the inbound message divided by the current gas price, or the global per-transaction gas limit."
	gas_limit(format: BigIntFormat): String
	"This parameter may be non-zero only for external inbound messages. It is the lesser of either the amount of gas that can be paid from the account balance or the maximum gas credit"
	gas_credit: Int
	mode: Int
	"These parameter represents the status values returned by TVM; for a successful transaction, exit_code has to be 0 or 1"
	exit_code: Int
	exit_arg: Int
	"the total number of steps performed by TVM (usually equal to two plus the number of instructions executed, including implicit RETs)"
	vm_steps: Float
	"This parameter is the representation hashes of the original state of TVM."
	vm_init_state_hash: String
	"This parameter is the representation hashes of the resulting state of TVM."
	vm_final_state_hash: String
}

type TransactionAction {
	success: Boolean
	valid: Boolean
	"The flag indicates absence of funds required to create an outbound message"
	no_funds: Boolean
	"""
	- 0 – unchanged
	- 1 – frozen
	- 2 – deleted
	"""
	status_change: Int
	status_change_name: AccountStatusChangeEnum
	total_fwd_fees(format: BigIntFormat): String
	total_action_fees(format: BigIntFormat): String
	result_code: Int
	result_arg: Int
	tot_actions: Int
	spec_actions: Int
	skipped_actions: Int
	msgs_created: Int
	action_list_hash: String
	total_msg_size_cells: Float
	total_msg_size_bits: Float
}

type TransactionBounce {
	"""
	- 0 – negFunds
	- 1 – noFunds
	- 2 – ok
	"""
	bounce_type: Int
	bounce_type_name: BounceTypeEnum
	msg_size_cells: Float
	msg_size_bits: Float
	req_fwd_fees(format: BigIntFormat): String
	msg_fees(format: BigIntFormat): String
	fwd_fees(format: BigIntFormat): String
}

type TransactionSplitInfo {
	"length of the current shard prefix"
	cur_shard_pfx_len: Int
	acc_split_depth: Int
	this_addr: String
	sibling_addr: String
}

"TON Transaction"
type Transaction {
	id: String
	"""
	Transaction type according to the original blockchain specification, clause 4.2.4.
	- 0 – ordinary
	- 1 – storage
	- 2 – tick
	- 3 – tock
	- 4 – splitPrepare
	- 5 – splitInstall
	- 6 – mergePrepare
	- 7 – mergeInstall
	"""
	tr_type: Int
	tr_type_name: TransactionTypeEnum
	"""
	Transaction processing status
	- 0 – unknown
	- 1 – preliminary
	- 2 – proposed
	- 3 – finalized
	- 4 – refused
	"""
	status: Int
	status_name: TransactionProcessingStatusEnum
	block_id: String
	block(timeout: Int, when: TransactionFilter): Block
	account_addr: String
	"Workchain id of the account address (account_addr field)"
	workchain_id: Int
	"Logical time. A component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see [the TON blockchain specification](https://test.ton.org/tblkch.pdf)."
	lt(format: BigIntFormat): String
	prev_trans_hash: String
	prev_trans_lt(format: BigIntFormat): String
	now: Float
	"The number of generated outbound messages (one of the common transaction parameters defined by the specification)"
	outmsg_cnt: Int
	"""
	The initial state of account. Note that in this case the query may return 0, if the account was not active before the transaction and 1 if it was already active
	- 0 – uninit
	- 1 – active
	- 2 – frozen
	- 3 – nonExist
	"""
	orig_status: Int
	orig_status_name: AccountStatusEnum
	"""
	The end state of an account after a transaction, 1 is returned to indicate a finalized transaction at an active account
	- 0 – uninit
	- 1 – active
	- 2 – frozen
	- 3 – nonExist
	"""
	end_status: Int
	end_status_name: AccountStatusEnum
	in_msg: String
	in_message(timeout: Int, when: TransactionFilter): Message
	out_msgs: [String]
	out_messages(timeout: Int, when: TransactionFilter): [Message]
	"Total amount of fees that entails account state change and used in Merkle update"
	total_fees(format: BigIntFormat): String
	"Same as above, but reserved for non gram coins that may appear in the blockchain"
	total_fees_other: [OtherCurrency]
	"Merkle update field"
	old_hash: String
	"Merkle update field"
	new_hash: String
	credit_first: Boolean
	storage: TransactionStorage
	credit: TransactionCredit
	compute: TransactionCompute
	action: TransactionAction
	bounce: TransactionBounce
	aborted: Boolean
	destroyed: Boolean
	tt: String
	split_info: TransactionSplitInfo
	prepare_transaction: String
	installed: Boolean
	proof: String
	boc: String
	balance_delta(format: BigIntFormat): String
	balance_delta_other: [OtherCurrency]
}

"""
# Message type

           Message layout queries.  A message consists of its header followed by its
           body or payload. The body is essentially arbitrary, to be interpreted by the
           destination smart contract. It can be queried with the following fields:
"""
type Message {
	id: String
	"""
	Returns the type of message.
	- 0 – internal
	- 1 – extIn
	- 2 – extOut
	"""
	msg_type: Int
	msg_type_name: MessageTypeEnum
	"""
	Returns internal processing status according to the numbers shown.
	- 0 – unknown
	- 1 – queued
	- 2 – processing
	- 3 – preliminary
	- 4 – proposed
	- 5 – finalized
	- 6 – refused
	- 7 – transiting
	"""
	status: Int
	status_name: MessageProcessingStatusEnum
	"Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64."
	block_id: String
	block(timeout: Int, when: MessageFilter): Block
	"Bag of cells with the message body encoded as base64."
	body: String
	"`body` field root hash."
	body_hash: String
	"This is only used for special contracts in masterchain to deploy messages."
	split_depth: Int
	"This is only used for special contracts in masterchain to deploy messages."
	tick: Boolean
	"This is only used for special contracts in masterchain to deploy messages"
	tock: Boolean
	"Represents contract code in deploy messages."
	code: String
	"`code` field root hash."
	code_hash: String
	"Represents initial data for a contract in deploy messages"
	data: String
	"`data` field root hash."
	data_hash: String
	"Represents contract library in deploy messages"
	library: String
	"`library` field root hash."
	library_hash: String
	"Returns source address string"
	src: String
	"Returns destination address string"
	dst: String
	"Workchain id of the source address (src field)"
	src_workchain_id: Int
	"Workchain id of the destination address (dst field)"
	dst_workchain_id: Int
	"Logical creation time automatically set by the generating transaction."
	created_lt(format: BigIntFormat): String
	"Creation unixtime automatically set by the generating transaction. The creation unixtime equals the creation unixtime of the block containing the generating transaction."
	created_at: Float
	created_at_string: String
	"IHR is disabled for the message."
	ihr_disabled: Boolean
	"This value is subtracted from the value attached to the message and awarded to the validators of the destination shardchain if they include the message by the IHR mechanism."
	ihr_fee(format: BigIntFormat): String
	"Original total forwarding fee paid for using the HR mechanism; it is automatically computed from some configuration parameters and the size of the message at the time the message is generated."
	fwd_fee(format: BigIntFormat): String
	import_fee(format: BigIntFormat): String
	"Bounce flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender."
	bounce: Boolean
	"Bounced flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender."
	bounced: Boolean
	"May or may not be present"
	value(format: BigIntFormat): String
	"May or may not be present."
	value_other: [OtherCurrency]
	"Merkle proof that message is a part of a block it cut from. It is a bag of cells with Merkle proof struct encoded as base64."
	proof: String
	"A bag of cells with the message structure encoded as base64."
	boc: String
	src_transaction(timeout: Int, when: MessageFilter): Transaction
	dst_transaction(timeout: Int, when: MessageFilter): Transaction
}

"""

# Account type

Recall that a smart contract and an account are the same thing in the context
of the TON Blockchain, and that these terms can be used interchangeably, at
least as long as only small (or “usual”) smart contracts are considered. A large
smart-contract may employ several accounts lying in different shardchains of
the same workchain for load balancing purposes.

An account is identified by its full address and is completely described by
its state. In other words, there is nothing else in an account apart from its
address and state.
           
"""
type Account {
	id: String
	"Workchain id of the account address (id field)."
	workchain_id: Int
	"""
	Returns the current status of the account.
	```
	{
	  accounts(filter: {acc_type:{eq:1}}){
	    id
	    acc_type
	  }
	}
	```
	        
	- 0 – uninit
	- 1 – active
	- 2 – frozen
	"""
	acc_type: Int
	acc_type_name: AccountTypeEnum
	"""
	
	Contains either the unixtime of the most recent storage payment
	collected (usually this is the unixtime of the most recent transaction),
	or the unixtime when the account was created (again, by a transaction).
	```
	query{
	  accounts(filter: {
	    last_paid:{ge:1567296000}
	  }) {
	  id
	  last_paid}
	}
	```     
	                
	"""
	last_paid: Float
	"""
	
	If present, accumulates the storage payments that could not be exacted from the balance of the account, represented by a strictly positive amount of nanograms; it can be present only for uninitialized or frozen accounts that have a balance of zero Grams (but may have non-zero balances in non gram cryptocurrencies). When due_payment becomes larger than the value of a configurable parameter of the blockchain, the ac- count is destroyed altogether, and its balance, if any, is transferred to the zero account.
	```
	{
	  accounts(filter: { due_payment: { ne: null } })
	    {
	      id
	    }
	}
	```
	        
	"""
	due_payment(format: BigIntFormat): String
	last_trans_lt(format: BigIntFormat): String
	"""
	
	```
	{
	  accounts(orderBy:{path:"balance",direction:DESC}){
	    balance
	  }
	}
	```
	        
	"""
	balance(format: BigIntFormat): String
	balance_other: [OtherCurrency]
	"Is present and non-zero only in instances of large smart contracts."
	split_depth: Int
	"May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function."
	tick: Boolean
	"""
	May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function.
	```        
	{
	  accounts (filter:{tock:{ne:null}}){
	    id
	    tock
	    tick
	  }
	}
	```
	        
	"""
	tock: Boolean
	"""
	If present, contains smart-contract code encoded with in base64.
	```  
	{
	  accounts (filter:{code:{eq:null}}){
	    id
	    acc_type
	  }
	}   
	```          
	        
	        
	        
	"""
	code: String
	"`code` field root hash."
	code_hash: String
	"If present, contains smart-contract data encoded with in base64."
	data: String
	"`data` field root hash."
	data_hash: String
	"If present, contains library code used in smart-contract."
	library: String
	"`library` field root hash."
	library_hash: String
	"Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64."
	proof: String
	"Bag of cells with the account struct encoded as base64."
	boc: String
}

input OtherCurrencyFilter {
	currency: FloatFilter
	value: StringFilter
    OR: OtherCurrencyFilter
}

input ExtBlkRefFilter {
	end_lt: StringFilter
	seq_no: FloatFilter
	root_hash: StringFilter
	file_hash: StringFilter
    OR: ExtBlkRefFilter
}

input MsgEnvelopeFilter {
	msg_id: StringFilter
	next_addr: StringFilter
	cur_addr: StringFilter
	fwd_fee_remaining: StringFilter
    OR: MsgEnvelopeFilter
}

input InMsgTypeEnumFilter {
	eq: InMsgTypeEnum
	ne: InMsgTypeEnum
	gt: InMsgTypeEnum
	lt: InMsgTypeEnum
	ge: InMsgTypeEnum
	le: InMsgTypeEnum
	in: [InMsgTypeEnum]
	notIn: [InMsgTypeEnum]
}

input InMsgFilter {
	"""
	- 0 – external
	- 1 – ihr
	- 2 – immediately
	- 3 – final
	- 4 – transit
	- 5 – discardedFinal
	- 6 – discardedTransit
	"""
	msg_type: IntFilter
	msg_type_name: InMsgTypeEnumFilter
	msg_id: StringFilter
	ihr_fee: StringFilter
	proof_created: StringFilter
	in_msg: MsgEnvelopeFilter
	fwd_fee: StringFilter
	out_msg: MsgEnvelopeFilter
	transit_fee: StringFilter
	transaction_id: StringFilter
	proof_delivered: StringFilter
    OR: InMsgFilter
}

input OutMsgTypeEnumFilter {
	eq: OutMsgTypeEnum
	ne: OutMsgTypeEnum
	gt: OutMsgTypeEnum
	lt: OutMsgTypeEnum
	ge: OutMsgTypeEnum
	le: OutMsgTypeEnum
	in: [OutMsgTypeEnum]
	notIn: [OutMsgTypeEnum]
}

input OutMsgFilter {
	"""
	- 0 – external
	- 1 – immediately
	- 2 – outMsgNew
	- 3 – transit
	- 4 – dequeueImmediately
	- 5 – dequeue
	- 6 – transitRequired
	- 7 – dequeueShort
	- -1 – none
	"""
	msg_type: IntFilter
	msg_type_name: OutMsgTypeEnumFilter
	msg_id: StringFilter
	transaction_id: StringFilter
	out_msg: MsgEnvelopeFilter
	reimport: InMsgFilter
	imported: InMsgFilter
	import_block_lt: StringFilter
	msg_env_hash: StringFilter
	next_workchain: IntFilter
	next_addr_pfx: StringFilter
    OR: OutMsgFilter
}

input OtherCurrencyArrayFilter {
	any: OtherCurrencyFilter
	all: OtherCurrencyFilter
}

input BlockValueFlowFilter {
	"Amount of grams amount to the next block."
	to_next_blk: StringFilter
	"Amount of non gram cryptocurrencies to the next block."
	to_next_blk_other: OtherCurrencyArrayFilter
	"Amount of grams exported."
	exported: StringFilter
	"Amount of non gram cryptocurrencies exported."
	exported_other: OtherCurrencyArrayFilter
	fees_collected: StringFilter
	fees_collected_other: OtherCurrencyArrayFilter
	created: StringFilter
	created_other: OtherCurrencyArrayFilter
	"Amount of grams imported."
	imported: StringFilter
	"Amount of non gram cryptocurrencies imported."
	imported_other: OtherCurrencyArrayFilter
	"Amount of grams transferred from previous block."
	from_prev_blk: StringFilter
	"Amount of non gram cryptocurrencies transferred from previous block."
	from_prev_blk_other: OtherCurrencyArrayFilter
	"Amount of grams minted in this block."
	minted: StringFilter
	minted_other: OtherCurrencyArrayFilter
	"Amount of import fees in grams"
	fees_imported: StringFilter
	"Amount of import fees in non gram currencies."
	fees_imported_other: OtherCurrencyArrayFilter
    OR: BlockValueFlowFilter
}

input BlockAccountBlocksTransactionsFilter {
	lt: StringFilter
	transaction_id: StringFilter
	total_fees: StringFilter
	total_fees_other: OtherCurrencyArrayFilter
    OR: BlockAccountBlocksTransactionsFilter
}

input BlockAccountBlocksTransactionsArrayFilter {
	any: BlockAccountBlocksTransactionsFilter
	all: BlockAccountBlocksTransactionsFilter
}

input BlockAccountBlocksFilter {
	account_addr: StringFilter
	transactions: BlockAccountBlocksTransactionsArrayFilter
	"old version of block hashes"
	old_hash: StringFilter
	"new version of block hashes"
	new_hash: StringFilter
	tr_count: IntFilter
    OR: BlockAccountBlocksFilter
}

input BlockStateUpdateFilter {
	new: StringFilter
	new_hash: StringFilter
	new_depth: IntFilter
	old: StringFilter
	old_hash: StringFilter
	old_depth: IntFilter
    OR: BlockStateUpdateFilter
}

input SplitTypeEnumFilter {
	eq: SplitTypeEnum
	ne: SplitTypeEnum
	gt: SplitTypeEnum
	lt: SplitTypeEnum
	ge: SplitTypeEnum
	le: SplitTypeEnum
	in: [SplitTypeEnum]
	notIn: [SplitTypeEnum]
}

"Shard description"
input BlockMasterShardHashesDescrFilter {
	"uint32 sequence number"
	seq_no: FloatFilter
	"Returns last known master block at the time of shard generation."
	reg_mc_seqno: FloatFilter
	"Logical time of the shardchain start"
	start_lt: StringFilter
	"Logical time of the shardchain end"
	end_lt: StringFilter
	"Returns last known master block at the time of shard generation. The shard block configuration is derived from that block."
	root_hash: StringFilter
	"Shard block file hash."
	file_hash: StringFilter
	"""
	TON Blockchain supports dynamic sharding, so the shard configuration may change from block to block because of shard merge and split events. Therefore, we cannot simply say that each shardchain corresponds to a fixed set of account chains.
	A shardchain block and its state may each be classified into two distinct parts. The parts with the ISP-dictated form of will be called the split parts of the block and its state, while the remainder will be called the non-split parts.
	The masterchain cannot be split or merged.
	"""
	before_split: BooleanFilter
	before_merge: BooleanFilter
	want_split: BooleanFilter
	want_merge: BooleanFilter
	nx_cc_updated: BooleanFilter
	flags: IntFilter
	next_catchain_seqno: FloatFilter
	next_validator_shard: StringFilter
	min_ref_mc_seqno: FloatFilter
	"Generation time in uint32"
	gen_utime: FloatFilter
	"""
	- 0 – none
	- 2 – split
	- 3 – merge
	"""
	split_type: IntFilter
	split_type_name: SplitTypeEnumFilter
	split: FloatFilter
	"Amount of fees collected int his shard in grams."
	fees_collected: StringFilter
	"Amount of fees collected int his shard in non gram currencies."
	fees_collected_other: OtherCurrencyArrayFilter
	"Amount of funds created in this shard in grams."
	funds_created: StringFilter
	"Amount of funds created in this shard in non gram currencies."
	funds_created_other: OtherCurrencyArrayFilter
    OR: BlockMasterShardHashesDescrFilter
}

input BlockMasterShardHashesFilter {
	"Uint32 workchain ID"
	workchain_id: IntFilter
	"Shard ID"
	shard: StringFilter
	"Shard description"
	descr: BlockMasterShardHashesDescrFilter
    OR: BlockMasterShardHashesFilter
}

input BlockMasterShardFeesFilter {
	workchain_id: IntFilter
	shard: StringFilter
	"Amount of fees in grams"
	fees: StringFilter
	"Array of fees in non gram crypto currencies"
	fees_other: OtherCurrencyArrayFilter
	"Amount of fees created during shard"
	create: StringFilter
	"Amount of non gram fees created in non gram crypto currencies during the block."
	create_other: OtherCurrencyArrayFilter
    OR: BlockMasterShardFeesFilter
}

input BlockMasterPrevBlkSignaturesFilter {
	node_id: StringFilter
	r: StringFilter
	s: StringFilter
    OR: BlockMasterPrevBlkSignaturesFilter
}

"Configuration parameter 6"
input BlockMasterConfigP6Filter {
	mint_new_price: StringFilter
	mint_add_price: StringFilter
    OR: BlockMasterConfigP6Filter
}

input BlockMasterConfigP7Filter {
	currency: FloatFilter
	value: StringFilter
    OR: BlockMasterConfigP7Filter
}

"Global version"
input BlockMasterConfigP8Filter {
	version: FloatFilter
	capabilities: StringFilter
    OR: BlockMasterConfigP8Filter
}

input ConfigProposalSetupFilter {
	min_tot_rounds: IntFilter
	max_tot_rounds: IntFilter
	min_wins: IntFilter
	max_losses: IntFilter
	min_store_sec: FloatFilter
	max_store_sec: FloatFilter
	bit_price: FloatFilter
	cell_price: FloatFilter
    OR: ConfigProposalSetupFilter
}

"Config voting setup"
input BlockMasterConfigP11Filter {
	normal_params: ConfigProposalSetupFilter
	critical_params: ConfigProposalSetupFilter
    OR: BlockMasterConfigP11Filter
}

input BlockMasterConfigP12Filter {
	workchain_id: IntFilter
	enabled_since: FloatFilter
	actual_min_split: IntFilter
	min_split: IntFilter
	max_split: IntFilter
	active: BooleanFilter
	accept_msgs: BooleanFilter
	flags: IntFilter
	zerostate_root_hash: StringFilter
	zerostate_file_hash: StringFilter
	version: FloatFilter
	basic: BooleanFilter
	vm_version: IntFilter
	vm_mode: StringFilter
	min_addr_len: IntFilter
	max_addr_len: IntFilter
	addr_len_step: IntFilter
	workchain_type_id: FloatFilter
    OR: BlockMasterConfigP12Filter
}

"Block create fees"
input BlockMasterConfigP14Filter {
	masterchain_block_fee: StringFilter
	basechain_block_fee: StringFilter
    OR: BlockMasterConfigP14Filter
}

"Election parameters"
input BlockMasterConfigP15Filter {
	validators_elected_for: FloatFilter
	elections_start_before: FloatFilter
	elections_end_before: FloatFilter
	stake_held_for: FloatFilter
    OR: BlockMasterConfigP15Filter
}

"Validators count"
input BlockMasterConfigP16Filter {
	max_validators: IntFilter
	max_main_validators: IntFilter
	min_validators: IntFilter
    OR: BlockMasterConfigP16Filter
}

"Validator stake parameters"
input BlockMasterConfigP17Filter {
	min_stake: StringFilter
	max_stake: StringFilter
	min_total_stake: StringFilter
	max_stake_factor: FloatFilter
    OR: BlockMasterConfigP17Filter
}

input BlockMasterConfigP18Filter {
	utime_since: FloatFilter
	bit_price_ps: StringFilter
	cell_price_ps: StringFilter
	mc_bit_price_ps: StringFilter
	mc_cell_price_ps: StringFilter
    OR: BlockMasterConfigP18Filter
}

input GasLimitsPricesFilter {
	gas_price: StringFilter
	gas_limit: StringFilter
	special_gas_limit: StringFilter
	gas_credit: StringFilter
	block_gas_limit: StringFilter
	freeze_due_limit: StringFilter
	delete_due_limit: StringFilter
	flat_gas_limit: StringFilter
	flat_gas_price: StringFilter
    OR: GasLimitsPricesFilter
}

input BlockLimitsBytesFilter {
	underload: FloatFilter
	soft_limit: FloatFilter
	hard_limit: FloatFilter
    OR: BlockLimitsBytesFilter
}

input BlockLimitsGasFilter {
	underload: FloatFilter
	soft_limit: FloatFilter
	hard_limit: FloatFilter
    OR: BlockLimitsGasFilter
}

input BlockLimitsLtDeltaFilter {
	underload: FloatFilter
	soft_limit: FloatFilter
	hard_limit: FloatFilter
    OR: BlockLimitsLtDeltaFilter
}

input BlockLimitsFilter {
	bytes: BlockLimitsBytesFilter
	gas: BlockLimitsGasFilter
	lt_delta: BlockLimitsLtDeltaFilter
    OR: BlockLimitsFilter
}

input MsgForwardPricesFilter {
	lump_price: StringFilter
	bit_price: StringFilter
	cell_price: StringFilter
	ihr_price_factor: FloatFilter
	first_frac: IntFilter
	next_frac: IntFilter
    OR: MsgForwardPricesFilter
}

"Catchain config"
input BlockMasterConfigP28Filter {
	shuffle_mc_validators: BooleanFilter
	mc_catchain_lifetime: FloatFilter
	shard_catchain_lifetime: FloatFilter
	shard_validators_lifetime: FloatFilter
	shard_validators_num: FloatFilter
    OR: BlockMasterConfigP28Filter
}

"Consensus config"
input BlockMasterConfigP29Filter {
	new_catchain_ids: BooleanFilter
	round_candidates: FloatFilter
	next_candidate_delay_ms: FloatFilter
	consensus_timeout_ms: FloatFilter
	fast_attempts: FloatFilter
	attempt_duration: FloatFilter
	catchain_max_deps: FloatFilter
	max_block_bytes: FloatFilter
	max_collated_bytes: FloatFilter
    OR: BlockMasterConfigP29Filter
}

input ValidatorSetListFilter {
	public_key: StringFilter
	weight: StringFilter
	adnl_addr: StringFilter
    OR: ValidatorSetListFilter
}

input ValidatorSetListArrayFilter {
	any: ValidatorSetListFilter
	all: ValidatorSetListFilter
}

input ValidatorSetFilter {
	utime_since: FloatFilter
	utime_until: FloatFilter
	total: IntFilter
	total_weight: StringFilter
	list: ValidatorSetListArrayFilter
    OR: ValidatorSetFilter
}

input BlockMasterConfigP39Filter {
	adnl_addr: StringFilter
	temp_public_key: StringFilter
	seqno: FloatFilter
	valid_until: FloatFilter
	signature_r: StringFilter
	signature_s: StringFilter
    OR: BlockMasterConfigP39Filter
}

input BlockMasterConfigP7ArrayFilter {
	any: BlockMasterConfigP7Filter
	all: BlockMasterConfigP7Filter
}

input FloatArrayFilter {
	any: FloatFilter
	all: FloatFilter
}

input BlockMasterConfigP12ArrayFilter {
	any: BlockMasterConfigP12Filter
	all: BlockMasterConfigP12Filter
}

input BlockMasterConfigP18ArrayFilter {
	any: BlockMasterConfigP18Filter
	all: BlockMasterConfigP18Filter
}

input StringArrayFilter {
	any: StringFilter
	all: StringFilter
}

input BlockMasterConfigP39ArrayFilter {
	any: BlockMasterConfigP39Filter
	all: BlockMasterConfigP39Filter
}

input BlockMasterConfigFilter {
	"Address of config smart contract in the masterchain"
	p0: StringFilter
	"Address of elector smart contract in the masterchain"
	p1: StringFilter
	"Address of minter smart contract in the masterchain"
	p2: StringFilter
	"Address of fee collector smart contract in the masterchain"
	p3: StringFilter
	"Address of TON DNS root smart contract in the masterchain"
	p4: StringFilter
	"Configuration parameter 6"
	p6: BlockMasterConfigP6Filter
	"Configuration parameter 7"
	p7: BlockMasterConfigP7ArrayFilter
	"Global version"
	p8: BlockMasterConfigP8Filter
	p9: FloatArrayFilter
	p10: FloatArrayFilter
	"Config voting setup"
	p11: BlockMasterConfigP11Filter
	"Array of all workchains descriptions"
	p12: BlockMasterConfigP12ArrayFilter
	"Block create fees"
	p14: BlockMasterConfigP14Filter
	"Election parameters"
	p15: BlockMasterConfigP15Filter
	"Validators count"
	p16: BlockMasterConfigP16Filter
	"Validator stake parameters"
	p17: BlockMasterConfigP17Filter
	"Storage prices"
	p18: BlockMasterConfigP18ArrayFilter
	"Gas limits and prices in the masterchain"
	p20: GasLimitsPricesFilter
	"Gas limits and prices in workchains"
	p21: GasLimitsPricesFilter
	"Block limits in the masterchain"
	p22: BlockLimitsFilter
	"Block limits in workchains"
	p23: BlockLimitsFilter
	"Message forward prices in the masterchain"
	p24: MsgForwardPricesFilter
	"Message forward prices in workchains"
	p25: MsgForwardPricesFilter
	"Catchain config"
	p28: BlockMasterConfigP28Filter
	"Consensus config"
	p29: BlockMasterConfigP29Filter
	p31: StringArrayFilter
	"Previous validators set"
	p32: ValidatorSetFilter
	"Previous temprorary validators set"
	p33: ValidatorSetFilter
	"Current validators set"
	p34: ValidatorSetFilter
	"Current temprorary validators set"
	p35: ValidatorSetFilter
	"Next validators set"
	p36: ValidatorSetFilter
	"Next temprorary validators set"
	p37: ValidatorSetFilter
	"Array of validator signed temprorary keys"
	p39: BlockMasterConfigP39ArrayFilter
    OR: BlockMasterConfigFilter
}

input BlockMasterShardHashesArrayFilter {
	any: BlockMasterShardHashesFilter
	all: BlockMasterShardHashesFilter
}

input BlockMasterShardFeesArrayFilter {
	any: BlockMasterShardFeesFilter
	all: BlockMasterShardFeesFilter
}

input BlockMasterPrevBlkSignaturesArrayFilter {
	any: BlockMasterPrevBlkSignaturesFilter
	all: BlockMasterPrevBlkSignaturesFilter
}

input BlockMasterFilter {
	"Min block generation time of shards"
	min_shard_gen_utime: FloatFilter
	"Max block generation time of shards"
	max_shard_gen_utime: FloatFilter
	shard_hashes: BlockMasterShardHashesArrayFilter
	shard_fees: BlockMasterShardFeesArrayFilter
	recover_create_msg: InMsgFilter
	prev_blk_signatures: BlockMasterPrevBlkSignaturesArrayFilter
	config_addr: StringFilter
	config: BlockMasterConfigFilter
    OR: BlockMasterFilter
}

input BlockSignaturesSignaturesFilter {
	node_id: StringFilter
	"'R' part of signature"
	r: StringFilter
	"'s' part of signature"
	s: StringFilter
    OR: BlockSignaturesSignaturesFilter
}

input BlockSignaturesSignaturesArrayFilter {
	any: BlockSignaturesSignaturesFilter
	all: BlockSignaturesSignaturesFilter
}

"Set of validator's signatures for the Block with correspond id"
input BlockSignaturesFilter {
	id: StringFilter
	"Signed block's gen_utime"
	gen_utime: FloatFilter
	"Signed block's seq_no"
	seq_no: FloatFilter
	"Signed block's shard"
	shard: StringFilter
	"Signed block's workchain_id"
	workchain_id: IntFilter
	"Signed block's merkle proof"
	proof: StringFilter
	validator_list_hash_short: FloatFilter
	catchain_seqno: FloatFilter
	sig_weight: StringFilter
	"Array of signatures from block's validators"
	signatures: BlockSignaturesSignaturesArrayFilter
	block: BlockFilter
    OR: BlockSignaturesFilter
}

input InMsgArrayFilter {
	any: InMsgFilter
	all: InMsgFilter
}

input OutMsgArrayFilter {
	any: OutMsgFilter
	all: OutMsgFilter
}

input BlockAccountBlocksArrayFilter {
	any: BlockAccountBlocksFilter
	all: BlockAccountBlocksFilter
}

input BlockProcessingStatusEnumFilter {
	eq: BlockProcessingStatusEnum
	ne: BlockProcessingStatusEnum
	gt: BlockProcessingStatusEnum
	lt: BlockProcessingStatusEnum
	ge: BlockProcessingStatusEnum
	le: BlockProcessingStatusEnum
	in: [BlockProcessingStatusEnum]
	notIn: [BlockProcessingStatusEnum]
}

"This is Block"
input BlockFilter {
	id: StringFilter
	"""
	Returns block processing status
	- 0 – unknown
	- 1 – proposed
	- 2 – finalized
	- 3 – refused
	"""
	status: IntFilter
	status_name: BlockProcessingStatusEnumFilter
	"uint32 global block ID"
	global_id: FloatFilter
	want_split: BooleanFilter
	seq_no: FloatFilter
	after_merge: BooleanFilter
	"uint 32 generation time stamp"
	gen_utime: FloatFilter
	gen_catchain_seqno: FloatFilter
	flags: IntFilter
	master_ref: ExtBlkRefFilter
	"External block reference for previous block."
	prev_ref: ExtBlkRefFilter
	"External block reference for previous block in case of shard merge."
	prev_alt_ref: ExtBlkRefFilter
	"External block reference for previous block in case of vertical blocks."
	prev_vert_ref: ExtBlkRefFilter
	prev_vert_alt_ref: ExtBlkRefFilter
	"uin32 block version identifier"
	version: FloatFilter
	gen_validator_list_hash_short: FloatFilter
	before_split: BooleanFilter
	after_split: BooleanFilter
	want_merge: BooleanFilter
	vert_seq_no: FloatFilter
	"""
	Logical creation time automatically set by the block formation start.
	Logical time is a component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see the TON blockchain specification
	"""
	start_lt: StringFilter
	"Logical creation time automatically set by the block formation end."
	end_lt: StringFilter
	"uint32 workchain identifier"
	workchain_id: IntFilter
	shard: StringFilter
	"Returns last known master block at the time of shard generation."
	min_ref_mc_seqno: FloatFilter
	"Returns a number of a previous key block."
	prev_key_block_seqno: FloatFilter
	gen_software_version: FloatFilter
	gen_software_capabilities: StringFilter
	value_flow: BlockValueFlowFilter
	in_msg_descr: InMsgArrayFilter
	rand_seed: StringFilter
	create_by: StringFilter
	out_msg_descr: OutMsgArrayFilter
	account_blocks: BlockAccountBlocksArrayFilter
	tr_count: IntFilter
	state_update: BlockStateUpdateFilter
	master: BlockMasterFilter
	"true if this block is a key block"
	key_block: BooleanFilter
	"Serialized bag of cell of this block encoded with base64"
	boc: StringFilter
	signatures: BlockSignaturesFilter
    OR: BlockFilter
}

input AccountStatusChangeEnumFilter {
	eq: AccountStatusChangeEnum
	ne: AccountStatusChangeEnum
	gt: AccountStatusChangeEnum
	lt: AccountStatusChangeEnum
	ge: AccountStatusChangeEnum
	le: AccountStatusChangeEnum
	in: [AccountStatusChangeEnum]
	notIn: [AccountStatusChangeEnum]
}

input TransactionStorageFilter {
	"This field defines the amount of storage fees collected in grams."
	storage_fees_collected: StringFilter
	"This field represents the amount of due fees in grams, it might be empty."
	storage_fees_due: StringFilter
	"""
	This field represents account status change after the transaction is completed.
	- 0 – unchanged
	- 1 – frozen
	- 2 – deleted
	"""
	status_change: IntFilter
	status_change_name: AccountStatusChangeEnumFilter
    OR: TransactionStorageFilter
}

input TransactionCreditFilter {
	"The sum of due_fees_collected and credit must equal the value of the message received, plus its ihr_fee if the message has not been received via Instant Hypercube Routing, IHR (otherwise the ihr_fee is awarded to the validators)."
	due_fees_collected: StringFilter
	credit: StringFilter
	credit_other: OtherCurrencyArrayFilter
    OR: TransactionCreditFilter
}

input ComputeTypeEnumFilter {
	eq: ComputeTypeEnum
	ne: ComputeTypeEnum
	gt: ComputeTypeEnum
	lt: ComputeTypeEnum
	ge: ComputeTypeEnum
	le: ComputeTypeEnum
	in: [ComputeTypeEnum]
	notIn: [ComputeTypeEnum]
}

input SkipReasonEnumFilter {
	eq: SkipReasonEnum
	ne: SkipReasonEnum
	gt: SkipReasonEnum
	lt: SkipReasonEnum
	ge: SkipReasonEnum
	le: SkipReasonEnum
	in: [SkipReasonEnum]
	notIn: [SkipReasonEnum]
}

input TransactionComputeFilter {
	"""
	- 0 – skipped
	- 1 – vm
	"""
	compute_type: IntFilter
	compute_type_name: ComputeTypeEnumFilter
	"""
	Reason for skipping the compute phase. According to the specification, the phase can be skipped due to the absence of funds to buy gas, absence of state of an account or a message, failure to provide a valid state in the message
	- 0 – noState
	- 1 – badState
	- 2 – noGas
	"""
	skipped_reason: IntFilter
	skipped_reason_name: SkipReasonEnumFilter
	"This flag is set if and only if exit_code is either 0 or 1."
	success: BooleanFilter
	"This parameter reflects whether the state passed in the message has been used. If it is set, the account_activated flag is used (see below)This parameter reflects whether the state passed in the message has been used. If it is set, the account_activated flag is used (see below)"
	msg_state_used: BooleanFilter
	"The flag reflects whether this has resulted in the activation of a previously frozen, uninitialized or non-existent account."
	account_activated: BooleanFilter
	"This parameter reflects the total gas fees collected by the validators for executing this transaction. It must be equal to the product of gas_used and gas_price from the current block header."
	gas_fees: StringFilter
	gas_used: StringFilter
	"This parameter reflects the gas limit for this instance of TVM. It equals the lesser of either the Grams credited in the credit phase from the value of the inbound message divided by the current gas price, or the global per-transaction gas limit."
	gas_limit: StringFilter
	"This parameter may be non-zero only for external inbound messages. It is the lesser of either the amount of gas that can be paid from the account balance or the maximum gas credit"
	gas_credit: IntFilter
	mode: IntFilter
	"These parameter represents the status values returned by TVM; for a successful transaction, exit_code has to be 0 or 1"
	exit_code: IntFilter
	exit_arg: IntFilter
	"the total number of steps performed by TVM (usually equal to two plus the number of instructions executed, including implicit RETs)"
	vm_steps: FloatFilter
	"This parameter is the representation hashes of the original state of TVM."
	vm_init_state_hash: StringFilter
	"This parameter is the representation hashes of the resulting state of TVM."
	vm_final_state_hash: StringFilter
    OR: TransactionComputeFilter
}

input TransactionActionFilter {
	success: BooleanFilter
	valid: BooleanFilter
	"The flag indicates absence of funds required to create an outbound message"
	no_funds: BooleanFilter
	"""
	- 0 – unchanged
	- 1 – frozen
	- 2 – deleted
	"""
	status_change: IntFilter
	status_change_name: AccountStatusChangeEnumFilter
	total_fwd_fees: StringFilter
	total_action_fees: StringFilter
	result_code: IntFilter
	result_arg: IntFilter
	tot_actions: IntFilter
	spec_actions: IntFilter
	skipped_actions: IntFilter
	msgs_created: IntFilter
	action_list_hash: StringFilter
	total_msg_size_cells: FloatFilter
	total_msg_size_bits: FloatFilter
    OR: TransactionActionFilter
}

input BounceTypeEnumFilter {
	eq: BounceTypeEnum
	ne: BounceTypeEnum
	gt: BounceTypeEnum
	lt: BounceTypeEnum
	ge: BounceTypeEnum
	le: BounceTypeEnum
	in: [BounceTypeEnum]
	notIn: [BounceTypeEnum]
}

input TransactionBounceFilter {
	"""
	- 0 – negFunds
	- 1 – noFunds
	- 2 – ok
	"""
	bounce_type: IntFilter
	bounce_type_name: BounceTypeEnumFilter
	msg_size_cells: FloatFilter
	msg_size_bits: FloatFilter
	req_fwd_fees: StringFilter
	msg_fees: StringFilter
	fwd_fees: StringFilter
    OR: TransactionBounceFilter
}

input TransactionSplitInfoFilter {
	"length of the current shard prefix"
	cur_shard_pfx_len: IntFilter
	acc_split_depth: IntFilter
	this_addr: StringFilter
	sibling_addr: StringFilter
    OR: TransactionSplitInfoFilter
}

input MessageArrayFilter {
	any: MessageFilter
	all: MessageFilter
}

input TransactionTypeEnumFilter {
	eq: TransactionTypeEnum
	ne: TransactionTypeEnum
	gt: TransactionTypeEnum
	lt: TransactionTypeEnum
	ge: TransactionTypeEnum
	le: TransactionTypeEnum
	in: [TransactionTypeEnum]
	notIn: [TransactionTypeEnum]
}

input TransactionProcessingStatusEnumFilter {
	eq: TransactionProcessingStatusEnum
	ne: TransactionProcessingStatusEnum
	gt: TransactionProcessingStatusEnum
	lt: TransactionProcessingStatusEnum
	ge: TransactionProcessingStatusEnum
	le: TransactionProcessingStatusEnum
	in: [TransactionProcessingStatusEnum]
	notIn: [TransactionProcessingStatusEnum]
}

input AccountStatusEnumFilter {
	eq: AccountStatusEnum
	ne: AccountStatusEnum
	gt: AccountStatusEnum
	lt: AccountStatusEnum
	ge: AccountStatusEnum
	le: AccountStatusEnum
	in: [AccountStatusEnum]
	notIn: [AccountStatusEnum]
}

"TON Transaction"
input TransactionFilter {
	id: StringFilter
	"""
	Transaction type according to the original blockchain specification, clause 4.2.4.
	- 0 – ordinary
	- 1 – storage
	- 2 – tick
	- 3 – tock
	- 4 – splitPrepare
	- 5 – splitInstall
	- 6 – mergePrepare
	- 7 – mergeInstall
	"""
	tr_type: IntFilter
	tr_type_name: TransactionTypeEnumFilter
	"""
	Transaction processing status
	- 0 – unknown
	- 1 – preliminary
	- 2 – proposed
	- 3 – finalized
	- 4 – refused
	"""
	status: IntFilter
	status_name: TransactionProcessingStatusEnumFilter
	block_id: StringFilter
	block: BlockFilter
	account_addr: StringFilter
	"Workchain id of the account address (account_addr field)"
	workchain_id: IntFilter
	"Logical time. A component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see [the TON blockchain specification](https://test.ton.org/tblkch.pdf)."
	lt: StringFilter
	prev_trans_hash: StringFilter
	prev_trans_lt: StringFilter
	now: FloatFilter
	"The number of generated outbound messages (one of the common transaction parameters defined by the specification)"
	outmsg_cnt: IntFilter
	"""
	The initial state of account. Note that in this case the query may return 0, if the account was not active before the transaction and 1 if it was already active
	- 0 – uninit
	- 1 – active
	- 2 – frozen
	- 3 – nonExist
	"""
	orig_status: IntFilter
	orig_status_name: AccountStatusEnumFilter
	"""
	The end state of an account after a transaction, 1 is returned to indicate a finalized transaction at an active account
	- 0 – uninit
	- 1 – active
	- 2 – frozen
	- 3 – nonExist
	"""
	end_status: IntFilter
	end_status_name: AccountStatusEnumFilter
	in_msg: StringFilter
	in_message: MessageFilter
	out_msgs: StringArrayFilter
	out_messages: MessageArrayFilter
	"Total amount of fees that entails account state change and used in Merkle update"
	total_fees: StringFilter
	"Same as above, but reserved for non gram coins that may appear in the blockchain"
	total_fees_other: OtherCurrencyArrayFilter
	"Merkle update field"
	old_hash: StringFilter
	"Merkle update field"
	new_hash: StringFilter
	credit_first: BooleanFilter
	storage: TransactionStorageFilter
	credit: TransactionCreditFilter
	compute: TransactionComputeFilter
	action: TransactionActionFilter
	bounce: TransactionBounceFilter
	aborted: BooleanFilter
	destroyed: BooleanFilter
	tt: StringFilter
	split_info: TransactionSplitInfoFilter
	prepare_transaction: StringFilter
	installed: BooleanFilter
	proof: StringFilter
	boc: StringFilter
	balance_delta: StringFilter
	balance_delta_other: OtherCurrencyArrayFilter
    OR: TransactionFilter
}

input MessageTypeEnumFilter {
	eq: MessageTypeEnum
	ne: MessageTypeEnum
	gt: MessageTypeEnum
	lt: MessageTypeEnum
	ge: MessageTypeEnum
	le: MessageTypeEnum
	in: [MessageTypeEnum]
	notIn: [MessageTypeEnum]
}

input MessageProcessingStatusEnumFilter {
	eq: MessageProcessingStatusEnum
	ne: MessageProcessingStatusEnum
	gt: MessageProcessingStatusEnum
	lt: MessageProcessingStatusEnum
	ge: MessageProcessingStatusEnum
	le: MessageProcessingStatusEnum
	in: [MessageProcessingStatusEnum]
	notIn: [MessageProcessingStatusEnum]
}

"""
# Message type

           Message layout queries.  A message consists of its header followed by its
           body or payload. The body is essentially arbitrary, to be interpreted by the
           destination smart contract. It can be queried with the following fields:
"""
input MessageFilter {
	id: StringFilter
	"""
	Returns the type of message.
	- 0 – internal
	- 1 – extIn
	- 2 – extOut
	"""
	msg_type: IntFilter
	msg_type_name: MessageTypeEnumFilter
	"""
	Returns internal processing status according to the numbers shown.
	- 0 – unknown
	- 1 – queued
	- 2 – processing
	- 3 – preliminary
	- 4 – proposed
	- 5 – finalized
	- 6 – refused
	- 7 – transiting
	"""
	status: IntFilter
	status_name: MessageProcessingStatusEnumFilter
	"Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64."
	block_id: StringFilter
	block: BlockFilter
	"Bag of cells with the message body encoded as base64."
	body: StringFilter
	"`body` field root hash."
	body_hash: StringFilter
	"This is only used for special contracts in masterchain to deploy messages."
	split_depth: IntFilter
	"This is only used for special contracts in masterchain to deploy messages."
	tick: BooleanFilter
	"This is only used for special contracts in masterchain to deploy messages"
	tock: BooleanFilter
	"Represents contract code in deploy messages."
	code: StringFilter
	"`code` field root hash."
	code_hash: StringFilter
	"Represents initial data for a contract in deploy messages"
	data: StringFilter
	"`data` field root hash."
	data_hash: StringFilter
	"Represents contract library in deploy messages"
	library: StringFilter
	"`library` field root hash."
	library_hash: StringFilter
	"Returns source address string"
	src: StringFilter
	"Returns destination address string"
	dst: StringFilter
	"Workchain id of the source address (src field)"
	src_workchain_id: IntFilter
	"Workchain id of the destination address (dst field)"
	dst_workchain_id: IntFilter
	"Logical creation time automatically set by the generating transaction."
	created_lt: StringFilter
	"Creation unixtime automatically set by the generating transaction. The creation unixtime equals the creation unixtime of the block containing the generating transaction."
	created_at: FloatFilter
	"IHR is disabled for the message."
	ihr_disabled: BooleanFilter
	"This value is subtracted from the value attached to the message and awarded to the validators of the destination shardchain if they include the message by the IHR mechanism."
	ihr_fee: StringFilter
	"Original total forwarding fee paid for using the HR mechanism; it is automatically computed from some configuration parameters and the size of the message at the time the message is generated."
	fwd_fee: StringFilter
	import_fee: StringFilter
	"Bounce flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender."
	bounce: BooleanFilter
	"Bounced flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender."
	bounced: BooleanFilter
	"May or may not be present"
	value: StringFilter
	"May or may not be present."
	value_other: OtherCurrencyArrayFilter
	"Merkle proof that message is a part of a block it cut from. It is a bag of cells with Merkle proof struct encoded as base64."
	proof: StringFilter
	"A bag of cells with the message structure encoded as base64."
	boc: StringFilter
	src_transaction: TransactionFilter
	dst_transaction: TransactionFilter
    OR: MessageFilter
}

input AccountTypeEnumFilter {
	eq: AccountTypeEnum
	ne: AccountTypeEnum
	gt: AccountTypeEnum
	lt: AccountTypeEnum
	ge: AccountTypeEnum
	le: AccountTypeEnum
	in: [AccountTypeEnum]
	notIn: [AccountTypeEnum]
}

"""

# Account type

Recall that a smart contract and an account are the same thing in the context
of the TON Blockchain, and that these terms can be used interchangeably, at
least as long as only small (or “usual”) smart contracts are considered. A large
smart-contract may employ several accounts lying in different shardchains of
the same workchain for load balancing purposes.

An account is identified by its full address and is completely described by
its state. In other words, there is nothing else in an account apart from its
address and state.
           
"""
input AccountFilter {
	id: StringFilter
	"Workchain id of the account address (id field)."
	workchain_id: IntFilter
	"""
	Returns the current status of the account.
	```
	{
	  accounts(filter: {acc_type:{eq:1}}){
	    id
	    acc_type
	  }
	}
	```
	        
	- 0 – uninit
	- 1 – active
	- 2 – frozen
	"""
	acc_type: IntFilter
	acc_type_name: AccountTypeEnumFilter
	"""
	
	Contains either the unixtime of the most recent storage payment
	collected (usually this is the unixtime of the most recent transaction),
	or the unixtime when the account was created (again, by a transaction).
	```
	query{
	  accounts(filter: {
	    last_paid:{ge:1567296000}
	  }) {
	  id
	  last_paid}
	}
	```     
	                
	"""
	last_paid: FloatFilter
	"""
	
	If present, accumulates the storage payments that could not be exacted from the balance of the account, represented by a strictly positive amount of nanograms; it can be present only for uninitialized or frozen accounts that have a balance of zero Grams (but may have non-zero balances in non gram cryptocurrencies). When due_payment becomes larger than the value of a configurable parameter of the blockchain, the ac- count is destroyed altogether, and its balance, if any, is transferred to the zero account.
	```
	{
	  accounts(filter: { due_payment: { ne: null } })
	    {
	      id
	    }
	}
	```
	        
	"""
	due_payment: StringFilter
	last_trans_lt: StringFilter
	"""
	
	```
	{
	  accounts(orderBy:{path:"balance",direction:DESC}){
	    balance
	  }
	}
	```
	        
	"""
	balance: StringFilter
	balance_other: OtherCurrencyArrayFilter
	"Is present and non-zero only in instances of large smart contracts."
	split_depth: IntFilter
	"May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function."
	tick: BooleanFilter
	"""
	May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function.
	```        
	{
	  accounts (filter:{tock:{ne:null}}){
	    id
	    tock
	    tick
	  }
	}
	```
	        
	"""
	tock: BooleanFilter
	"""
	If present, contains smart-contract code encoded with in base64.
	```  
	{
	  accounts (filter:{code:{eq:null}}){
	    id
	    acc_type
	  }
	}   
	```          
	        
	        
	        
	"""
	code: StringFilter
	"`code` field root hash."
	code_hash: StringFilter
	"If present, contains smart-contract data encoded with in base64."
	data: StringFilter
	"`data` field root hash."
	data_hash: StringFilter
	"If present, contains library code used in smart-contract."
	library: StringFilter
	"`library` field root hash."
	library_hash: StringFilter
	"Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64."
	proof: StringFilter
	"Bag of cells with the account struct encoded as base64."
	boc: StringFilter
    OR: AccountFilter
}

"Specify sort order direction"
enum QueryOrderByDirection {
    "Documents will be sorted in ascended order (e.g. from A to Z)"
    ASC
    "Documents will be sorted in descendant order (e.g. from Z to A)"
    DESC
}


"""
Specify how to sort results.
You can sort documents in result set using more than one field.
"""
input QueryOrderBy {
    """
    Path to field which must be used as a sort criteria.
    If field resides deep in structure path items must be separated with dot (e.g. 'foo.bar.baz').
    """
    path: String
    "Sort order direction"
    direction: QueryOrderByDirection
}

type Query {
	blocks_signatures(filter: BlockSignaturesFilter, orderBy: [QueryOrderBy], limit: Int, timeout: Float, accessKey: String, operationId: String): [BlockSignatures]
	blocks(filter: BlockFilter, orderBy: [QueryOrderBy], limit: Int, timeout: Float, accessKey: String, operationId: String): [Block]
	transactions(filter: TransactionFilter, orderBy: [QueryOrderBy], limit: Int, timeout: Float, accessKey: String, operationId: String): [Transaction]
	messages(filter: MessageFilter, orderBy: [QueryOrderBy], limit: Int, timeout: Float, accessKey: String, operationId: String): [Message]
	accounts(filter: AccountFilter, orderBy: [QueryOrderBy], limit: Int, timeout: Float, accessKey: String, operationId: String): [Account]
}

type Subscription {
	blocks_signatures(filter: BlockSignaturesFilter, accessKey: String): BlockSignatures
	blocks(filter: BlockFilter, accessKey: String): Block
	transactions(filter: TransactionFilter, accessKey: String): Transaction
	messages(filter: MessageFilter, accessKey: String): Message
	accounts(filter: AccountFilter, accessKey: String): Account
}
